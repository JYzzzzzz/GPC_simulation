    %2019-02-21 

%function: 计算GPC控制率，用于基本GPC开始时的控制率计算，以及间接自适应
          %算法每个t时刻参数估计后进行的步骤（详见相关资料查询原理）
%parameter: A：数组。存储被控对象的多项式的系数。可以是精确值也可以是估计值
%              a1,a2,a3,...
           %na：数值。为“A的阶数-1”
           %B：类似A。b0,b1,b2,...
           %nb：数值。为“B的阶数-1”，B的阶数规定>=2
           %N1：最大预测时域，规定最小预测时域N0为1
           %Nu：控制时域，Nu<=N1
           %lbd：加权系数λ
%return: 三项均为数组。为控制率的系数
function [P,Alpha,Beta] = GPC_getCtrlRule(A,na,B,nb,N1,Nu,lbd)
%--------------------------------------------------2 计算控制率
E=zeros(1,N1);
F=zeros(N1,na+1);
G=zeros(N1,Nu);
H=zeros(N1,nb);
%----------------------------------------2.1 递推E，F,G,H参数
%------------------------------2.1.1 初值
E(1) = 1;                  %e0
Ad = conv(A,[1 -1]);
for i=1:na+1
   F(1+((i-1)*N1)) = -Ad(i+1); %f1,0  f1,1  f1,2
end
G(1)=E(1)*B(1);
for i=1:nb
   H(1+((i-1)*N1)) = B(i+1); 
end
%------------------------------2.1.2 递推过程
if (N1>1)
    for j=2:N1         %递推过程
        
        E(j) = F(j-1+((1-1)*N1));
        
        for i=1:na
            F(j+((i-1)*N1)) = F(j-1+((i+1-1)*N1))-Ad(i+1)*E(j);
        end
        F(j+((na+1-1)*N1)) = -Ad(na+1+1)*E(j);
        
        G(j) = E(j)*B(1)+H(j-1+((1-1)*N1));
        
        if(nb>1)
            for i=1:nb-1
                H(j+((i-1)*N1)) = E(j)*B(i+1)+H(j-1+((i+1-1)*N1));
            end
        end
        H(j+((nb-1)*N1)) = E(j)*B(nb+1);
        
    end
end

for j=1:N1  %矩阵G
    i=1;
    while j+i<=N1 && 1+i<=Nu
        G(j+i+((1+i-1)*N1)) = G(j+((1-1)*N1));
        i=i+1;
    end
end

%--------------------  滚动优化  ---------------------
%----------------------------------------2.2 计算矩阵(GTG+LambdaI)，及其相关参数
G1 = G'*G+eye(Nu,Nu)*lbd;
G1 = inv(G1);   %求逆
G1 = G1*G';
%------------------------------ P有N1项，对设定值yr加权
P = G1(1,:);   %G1的第一行 ---> [P1 P2 ... PN1]
%------------------------------ Alpha有na+1项，对输出y加权
                              % Beta有nb项，对输出控制量的微分du加权
Alpha = zeros(1,na+1);  %Alpha是一组多项式
Beta = zeros(1,nb);
for j=1:N1
    Alpha = Alpha+F(j,:)*P(j);
    Beta = Beta+H(j,:)*P(j);
end
